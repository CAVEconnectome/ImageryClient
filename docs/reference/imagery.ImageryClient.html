<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ImageryClient – imagery.imageryclient</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../reference/composite.stack_images.html" rel="next">
<link href="../reference/imagery.bounds_from_center.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">ImageryClient</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../getting_started.html" rel="" target="">
 <span class="menu-text">Getting Started</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../tutorials/images.html" rel="" target="">
 <span class="dropdown-text">Using ImageryClient</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../tutorials/overlays.html" rel="" target="">
 <span class="dropdown-text">Making Overlays</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link active" href="../reference/index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Function Reference</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
    <a href="http://github.com/AllenInstitute/ImageryClient" rel="" title="Github" class="quarto-navigation-tool px-1" aria-label="Github"><i class="bi bi-github"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../reference/imagery.bounds_from_center.html">ImageryClient</a></li><li class="breadcrumb-item"><a href="../reference/imagery.ImageryClient.html">imagery.ImageryClient</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Function Reference</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">ImageryClient</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/imagery.bounds_from_center.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">imagery.bounds_from_center</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/imagery.ImageryClient.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">imagery.ImageryClient</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Compositing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/composite.stack_images.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">composite.stack_images</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/composite.composite_overlay.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">composite.composite_overlay</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Utilities</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/utils.binary_seg_outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">utils.binary_seg_outline</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/utils.mask_image.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">utils.mask_image</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/utils.segmentation_masks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">utils.segmentation_masks</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#imageryclient.imagery.ImageryClient" id="toc-imageryclient.imagery.ImageryClient" class="nav-link active" data-scroll-target="#imageryclient.imagery.ImageryClient">imagery.ImageryClient</a>
  <ul class="collapse">
  <li><a href="#parameters" id="toc-parameters" class="nav-link" data-scroll-target="#parameters">Parameters</a></li>
  <li><a href="#attributes" id="toc-attributes" class="nav-link" data-scroll-target="#attributes">Attributes</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a></li>
  <li><a href="#imageryclient.imagery.ImageryClient.image_and_segmentation_cutout" id="toc-imageryclient.imagery.ImageryClient.image_and_segmentation_cutout" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.image_and_segmentation_cutout">image_and_segmentation_cutout</a>
  <ul class="collapse">
  <li><a href="#parameters-1" id="toc-parameters-1" class="nav-link" data-scroll-target="#parameters-1">Parameters</a></li>
  <li><a href="#returns" id="toc-returns" class="nav-link" data-scroll-target="#returns">Returns</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions" id="toc-imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions">image_bbox_size_from_dimensions</a>
  <ul class="collapse">
  <li><a href="#parameters-2" id="toc-parameters-2" class="nav-link" data-scroll-target="#parameters-2">Parameters</a></li>
  <li><a href="#returns-1" id="toc-returns-1" class="nav-link" data-scroll-target="#returns-1">Returns</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.image_cutout" id="toc-imageryclient.imagery.ImageryClient.image_cutout" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.image_cutout">image_cutout</a>
  <ul class="collapse">
  <li><a href="#parameters-3" id="toc-parameters-3" class="nav-link" data-scroll-target="#parameters-3">Parameters</a></li>
  <li><a href="#returns-2" id="toc-returns-2" class="nav-link" data-scroll-target="#returns-2">Returns</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks" id="toc-imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks">save_image_and_segmentation_masks</a>
  <ul class="collapse">
  <li><a href="#parameters-4" id="toc-parameters-4" class="nav-link" data-scroll-target="#parameters-4">Parameters</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.save_imagery" id="toc-imageryclient.imagery.ImageryClient.save_imagery" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.save_imagery">save_imagery</a>
  <ul class="collapse">
  <li><a href="#parameters-5" id="toc-parameters-5" class="nav-link" data-scroll-target="#parameters-5">Parameters</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.save_segmentation_masks" id="toc-imageryclient.imagery.ImageryClient.save_segmentation_masks" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.save_segmentation_masks">save_segmentation_masks</a>
  <ul class="collapse">
  <li><a href="#parameters-6" id="toc-parameters-6" class="nav-link" data-scroll-target="#parameters-6">Parameters</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions" id="toc-imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions">segmentation_bbox_size_from_dimensions</a>
  <ul class="collapse">
  <li><a href="#parameters-7" id="toc-parameters-7" class="nav-link" data-scroll-target="#parameters-7">Parameters</a></li>
  <li><a href="#returns-3" id="toc-returns-3" class="nav-link" data-scroll-target="#returns-3">Returns</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.segmentation_cutout" id="toc-imageryclient.imagery.ImageryClient.segmentation_cutout" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.segmentation_cutout">segmentation_cutout</a>
  <ul class="collapse">
  <li><a href="#parameters-8" id="toc-parameters-8" class="nav-link" data-scroll-target="#parameters-8">Parameters</a></li>
  <li><a href="#returns-4" id="toc-returns-4" class="nav-link" data-scroll-target="#returns-4">Returns</a></li>
  </ul></li>
  <li><a href="#imageryclient.imagery.ImageryClient.split_segmentation_cutout" id="toc-imageryclient.imagery.ImageryClient.split_segmentation_cutout" class="nav-link" data-scroll-target="#imageryclient.imagery.ImageryClient.split_segmentation_cutout">split_segmentation_cutout</a>
  <ul class="collapse">
  <li><a href="#parameters-9" id="toc-parameters-9" class="nav-link" data-scroll-target="#parameters-9">Parameters</a></li>
  <li><a href="#returns-5" id="toc-returns-5" class="nav-link" data-scroll-target="#returns-5">Returns</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="imageryclient.imagery.ImageryClient" class="level1">
<h1>imagery.ImageryClient</h1>
<p><code>imagery.ImageryClient(self, client=None, resolution=None, segmentation=True, imagery=True, image_source=None, segmentation_source=None, image_mip=None, segmentation_mip=None, auth_token=None, timestamp=None)</code></p>
<p>Tool to help download imagery and segmentation data.</p>
<p>Can either take explicit cloudvolume paths for imagery and segmentation or use the Info Service to look up the right paths.</p>
<section id="parameters" class="level2">
<h2 class="anchored" data-anchor-id="parameters">Parameters</h2>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 17%">
<col style="width: 68%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>client</code></td>
<td>caveclient.caveclient.CAVEclient or None</td>
<td>A pre-initialized CAVEclient to use for configuration. If used, the image source and segmentation source come from the info service values.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>resolution</code></td>
<td>array - like or image or segmentation</td>
<td>Sets the voxel resolution that bounds will be entered in, by default ‘image’, which is the mip 0 resolution of the imagery.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>segmentation</code></td>
<td>bool</td>
<td>If False, no segmentation cloudvolume is initialized. By default True</td>
<td><code>True</code></td>
</tr>
<tr class="even">
<td><code>imagery</code></td>
<td>bool</td>
<td>If False, no imagery cloudvolume is initialized. By default True</td>
<td><code>True</code></td>
</tr>
<tr class="odd">
<td><code>image_source</code></td>
<td>str</td>
<td>CloudVolume path to an imagery source, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>segmentation_source</code></td>
<td>str</td>
<td>CloudVolume path to a segmentation source, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>image_mip</code></td>
<td>int</td>
<td>Default mip level to use for imagery lookups, by default 0. Note that the same mip level for imagery and segmentation can correspond to different voxel resolutions.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>segmentation_mip</code></td>
<td>int</td>
<td>Default mip level to use for segmentation lookups, by default 0.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>auth_token</code></td>
<td>str or None</td>
<td>Auth token to use for cloudvolume. If None, uses the default values from the CAVEclient. Default is None.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>timestamp</code></td>
<td>(datetime.datetime.datetime or None)</td>
<td>Fixed timestamp to use for segmentation lookups. If None, defaults to the present time when each function is run. Default is None.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="attributes" class="level2">
<h2 class="anchored" data-anchor-id="attributes">Attributes</h2>
<table class="table">
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.image_cv">image_cv</a></td>
<td>Imagery CloudVolume</td>
</tr>
<tr class="even">
<td><a href="#imageryclient.imagery.ImageryClient.image_source">image_source</a></td>
<td>Image cloudpath</td>
</tr>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.resolution">resolution</a></td>
<td>The voxel resolution assumed when locations are used for the client.</td>
</tr>
<tr class="even">
<td><a href="#imageryclient.imagery.ImageryClient.segmentation_cv">segmentation_cv</a></td>
<td>Segmentation CloudVolume object</td>
</tr>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.segmentation_source">segmentation_source</a></td>
<td>Segmentation cloudpath</td>
</tr>
</tbody>
</table>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<table class="table">
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.image_and_segmentation_cutout">image_and_segmentation_cutout</a></td>
<td>Download aligned and scaled imagery and segmentation data at a given resolution.</td>
</tr>
<tr class="even">
<td><a href="#imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions">image_bbox_size_from_dimensions</a></td>
<td>Get the bbox_size equivalent for an imagery cutout with specified pixel dimensions</td>
</tr>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.image_cutout">image_cutout</a></td>
<td>Get an image cutout for a certain location or set of bounds and a mip level.</td>
</tr>
<tr class="even">
<td><a href="#imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks">save_image_and_segmentation_masks</a></td>
<td>Save aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.</td>
</tr>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.save_imagery">save_imagery</a></td>
<td>Save queried or precomputed imagery to png files.</td>
</tr>
<tr class="even">
<td><a href="#imageryclient.imagery.ImageryClient.save_segmentation_masks">save_segmentation_masks</a></td>
<td>Save queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.</td>
</tr>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions">segmentation_bbox_size_from_dimensions</a></td>
<td>Get the bbox_size equivalent for an segmentation cutout with specified pixel dimensions</td>
</tr>
<tr class="even">
<td><a href="#imageryclient.imagery.ImageryClient.segmentation_cutout">segmentation_cutout</a></td>
<td>Get a cutout of the segmentation imagery for some or all root ids between set bounds.</td>
</tr>
<tr class="odd">
<td><a href="#imageryclient.imagery.ImageryClient.split_segmentation_cutout">split_segmentation_cutout</a></td>
<td>Generate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values.</td>
</tr>
</tbody>
</table>
</section>
<section id="imageryclient.imagery.ImageryClient.image_and_segmentation_cutout" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.image_and_segmentation_cutout">image_and_segmentation_cutout</h2>
<p><code>imagery.ImageryClient.image_and_segmentation_cutout(bounds, image_mip=None, segmentation_mip=None, root_ids='all', resize=True, split_segmentations=False, include_null_root=False, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)</code></p>
<p>Download aligned and scaled imagery and segmentation data at a given resolution.</p>
<section id="parameters-1" class="level3">
<h3 class="anchored" data-anchor-id="parameters-1">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 81%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bounds</code></td>
<td>2x3 list of ints</td>
<td>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>image_mip</code></td>
<td>int</td>
<td>Mip level of the imagery if something other than the default is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>segmentation_mip</code></td>
<td>int</td>
<td>Mip level of the segmentation if something other than the default is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>root_ids</code></td>
<td>list, None, or ‘all’</td>
<td>If a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.</td>
<td><code>'all'</code></td>
</tr>
<tr class="odd">
<td><code>resize</code></td>
<td>bool</td>
<td>If True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).</td>
<td><code>True</code></td>
</tr>
<tr class="even">
<td><code>split_segmentations</code></td>
<td>bool</td>
<td>If True, the segmentation is returned as a dict of masks (using split_segmentation_cutout), and if False returned as an array with root_ids (using segmentation_cutout), by default False</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>include_null_root</code></td>
<td>bool</td>
<td>If True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>timestamp</code></td>
<td>datetime or None</td>
<td>Timestamp to use for dynamic segmentation data</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>scale_to_bounds</code></td>
<td>bool or None</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>convert_to_int64</code></td>
<td>bool</td>
<td>If True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns" class="level3">
<h3 class="anchored" data-anchor-id="returns">Returns</h3>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 74%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cloudvolume.cloudvolume.VolumeCutout</td>
<td>Imagery volume cutout</td>
</tr>
<tr class="even">
<td>numpy.numpy.ndarray or dict</td>
<td>Segmentation volume cutout as either an ndarray or dict of masks depending on the split_segmentations flag.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.image_bbox_size_from_dimensions">image_bbox_size_from_dimensions</h2>
<p><code>imagery.ImageryClient.image_bbox_size_from_dimensions(image_size, mip=None, resolution=None)</code></p>
<p>Get the bbox_size equivalent for an imagery cutout with specified pixel dimensions</p>
<section id="parameters-2" class="level3">
<h3 class="anchored" data-anchor-id="parameters-2">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 6%">
<col style="width: 73%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>image_size</code></td>
<td></td>
<td>Image size in pixels (2-element) or voxels (3-element)</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>mip</code></td>
<td></td>
<td>Mip for which the image would be computed. Defaults to None, which uses the client default.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>resolution</code></td>
<td></td>
<td>Resolution to use for the bbox_size. Defaults to None, or the client defauls.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-1" class="level3">
<h3 class="anchored" data-anchor-id="returns-1">Returns</h3>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>Argument for bbox_size that would give the desired pixel dimensions.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.image_cutout" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.image_cutout">image_cutout</h2>
<p><code>imagery.ImageryClient.image_cutout(bounds, bbox_size=None, image_size=None, mip=None, resolution=None, scale_to_bounds=None)</code></p>
<p>Get an image cutout for a certain location or set of bounds and a mip level.</p>
<section id="parameters-3" class="level3">
<h3 class="anchored" data-anchor-id="parameters-3">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 85%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bounds</code></td>
<td>array</td>
<td>Either a 2x3 array of a lower bound and upper bound point to bound the cutout in units of voxels in a resolution set by the base_resolution parameter. Alternatively, if bbox_size or image_size is set, bounds should be a 3-element array specifying the center of the field of view.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>image_size</code></td>
<td>array or None</td>
<td>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>mip</code></td>
<td>int</td>
<td>Mip level of imagery to get if something other than the default is wanted, by default None.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>scale_to_bounds</code></td>
<td>bool, optional.</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-2" class="level3">
<h3 class="anchored" data-anchor-id="returns-2">Returns</h3>
<table class="table">
<colgroup>
<col style="width: 24%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cloudvolume.VolumeCutout</td>
<td>An n-d image of the image requested with image intensity values as the elements.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.save_image_and_segmentation_masks">save_image_and_segmentation_masks</h2>
<p><code>imagery.ImageryClient.save_image_and_segmentation_masks(filename_prefix, bounds=None, image_mip=None, segmentation_mip=None, root_ids='all', include_null_root=False, segmentation_colormap={}, resize=True, precomputed_data=None, slice_axis=2, bbox_size=None, resolution=None, timestamp=None, scale_to_bounds=None, **kwargs)</code></p>
<p>Save aligned and scaled imagery and segmentation mask cutouts as pngs. Kwargs are passed to imageio.imwrite.</p>
<section id="parameters-4" class="level3">
<h3 class="anchored" data-anchor-id="parameters-4">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 8%">
<col style="width: 7%">
<col style="width: 80%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>filename_prefix</code></td>
<td>str</td>
<td>Prefix for the segmentation filenames. The full filename will be either {filename_prefix}<em>root_id</em>{root_id}.png or {filename_prefix}<em>root_id</em>{root_id}_{i}.png, depending on if multiple slices of each root id are saved.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>bounds</code></td>
<td>2x3 list of ints</td>
<td>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed data is not passed. By default, None.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>image_mip</code></td>
<td>int</td>
<td>Only used if a precomputed data is not passed. Mip level of imagery to get if something other than the default is wanted, by default None.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>segmentation_mip</code></td>
<td>int</td>
<td>Only used if precomputed data is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>root_ids</code></td>
<td>list, None, or ‘all’</td>
<td>If a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.</td>
<td><code>'all'</code></td>
</tr>
<tr class="even">
<td><code>include_null_root</code></td>
<td>bool</td>
<td>If True, includes root id of 0, which is usually reserved for a null segmentation value. By default, False.</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>segmentation_colormap</code></td>
<td>dict</td>
<td>A dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.</td>
<td><code>{}</code></td>
</tr>
<tr class="even">
<td><code>resize</code></td>
<td>bool</td>
<td>If True, upscale the lower resolution cutout to the same resolution of the higher one (either imagery or segmentation).</td>
<td><code>True</code></td>
</tr>
<tr class="odd">
<td><code>precomputed_data</code></td>
<td>tuple</td>
<td>Already computed tuple with imagery and segmentation mask data, in that order. If not provided, bounds must be given to download cutout data. By default, None.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>slice_axis</code></td>
<td>int</td>
<td>If the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e.&nbsp;z-axis)</td>
<td><code>2</code></td>
</tr>
<tr class="odd">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution of the bounds provided. If not provided, uses the client defaults.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>timestamp</code></td>
<td>datetime</td>
<td>Timestamp to use for the segmentation. If not provided, defaults to the client defaults.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>scale_to_bounds</code></td>
<td>bool or None</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.save_imagery" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.save_imagery">save_imagery</h2>
<p><code>imagery.ImageryClient.save_imagery(filename_prefix, bounds=None, mip=None, precomputed_image=None, slice_axis=2, bbox_size=None, image_size=None, resolution=None, scale_to_bounds=None, verbose=False, **kwargs)</code></p>
<p>Save queried or precomputed imagery to png files.</p>
<section id="parameters-5" class="level3">
<h3 class="anchored" data-anchor-id="parameters-5">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 12%">
<col style="width: 76%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>filename_prefix</code></td>
<td>str</td>
<td>Prefix for the imagery filename. The full filename will be {filename_prefix}_imagery.png</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>bounds</code></td>
<td>2x3 list of ints</td>
<td>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter. Only used if a precomputed image is not passed. By default, None.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>mip</code></td>
<td>int</td>
<td>Only used if a precomputed image is not passed. Mip level of imagery to get if something other than the default is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>precomputed_image</code></td>
<td>cloudvolume.cloudvolume.VolumeCutout</td>
<td>Already downloaded VolumeCutout data to save explicitly. If called this way, the bounds and mip arguments will not apply. If a precomputed image is not provided, bounds must be specified to download the cutout data. By default None</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>slice_axis</code></td>
<td>int</td>
<td>If the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e.&nbsp;z-axis)</td>
<td><code>2</code></td>
</tr>
<tr class="even">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>image_size</code></td>
<td>array or None</td>
<td>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>scale_to_bounds</code></td>
<td>bool or None</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>verbose</code></td>
<td>bool</td>
<td>If True, prints the progress, by default False</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.save_segmentation_masks" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.save_segmentation_masks">save_segmentation_masks</h2>
<p><code>imagery.ImageryClient.save_segmentation_masks(filename_prefix, bounds=None, mip=None, root_ids='all', precomputed_masks=None, segmentation_colormap={}, slice_axis=2, include_null_root=False, bbox_size=None, image_size=None, resolution=None, timestamp=None, scale_to_bounds=None, verbose=False, **kwargs)</code></p>
<p>Save queried or precomputed segmentation masks to png files. Additional kwargs are passed to imageio.imwrite.</p>
<section id="parameters-6" class="level3">
<h3 class="anchored" data-anchor-id="parameters-6">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 8%">
<col style="width: 7%">
<col style="width: 80%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>filename_prefix</code></td>
<td>str</td>
<td>Prefix for the segmentation filenames. The full filename will be either {filename_prefix}<em>root_id</em>{root_id}.png or {filename_prefix}<em>root_id</em>{root_id}_{i}.png, depending on if multiple slices of each root id are saved.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>bounds</code></td>
<td>2x3 list of ints</td>
<td>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution specified. Only used if a precomputed segmentation is not passed. By default, None.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>mip</code></td>
<td>int</td>
<td>Only used if a precomputed segmentation is not passed. Mip level of segmentation to get if something other than the default is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>root_ids</code></td>
<td>list, None, or ‘all’</td>
<td>If a list, the segmentation cutout only includes voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, finds all root ids corresponding to the supervoxels in the cutout and get all of them. By default ‘all’.</td>
<td><code>'all'</code></td>
</tr>
<tr class="odd">
<td><code>precomputed_masks</code></td>
<td>dict</td>
<td>Already downloaded dict of mask data to save explicitly. If called this way, the bounds and mip arguments will not apply. If precomputed_masks are not provided, bounds must be given to download cutout data. By default None</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>segmentation_colormap</code></td>
<td>dict</td>
<td>A dict of root ids to an uint8 RGB color triplet (0-255) or RGBa quadrooplet to optionally color the mask png. Any root id not specified will be rendered in white. Color triplets default to full opacity. Default is an empty dictionary.</td>
<td><code>{}</code></td>
</tr>
<tr class="odd">
<td><code>slice_axis</code></td>
<td>int</td>
<td>If the image data is truly 3 dimensional, determines which axis to use to save serial images, by default 2 (i.e.&nbsp;z-axis)</td>
<td><code>2</code></td>
</tr>
<tr class="even">
<td><code>include_null_root</code></td>
<td>bool</td>
<td>If True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions of the cutout. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>image_size</code></td>
<td>array or None</td>
<td>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>timestamp</code></td>
<td>datetime or None</td>
<td>Timestamp to use for dynamic segmentation data</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>scale_to_bounds</code></td>
<td>bool or None</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.segmentation_bbox_size_from_dimensions">segmentation_bbox_size_from_dimensions</h2>
<p><code>imagery.ImageryClient.segmentation_bbox_size_from_dimensions(image_size, mip=None, resolution=None)</code></p>
<p>Get the bbox_size equivalent for an segmentation cutout with specified pixel dimensions</p>
<section id="parameters-7" class="level3">
<h3 class="anchored" data-anchor-id="parameters-7">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 6%">
<col style="width: 73%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>image_size</code></td>
<td></td>
<td>Image size in pixels (2-element) or voxels (3-element)</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>mip</code></td>
<td></td>
<td>Mip for which the image would be computed. Defaults to None, which uses the client default.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>resolution</code></td>
<td></td>
<td>Resolution to use for the bbox_size. Defaults to None, or the client defauls.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-3" class="level3">
<h3 class="anchored" data-anchor-id="returns-3">Returns</h3>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>Argument for bbox_size that would give the desired pixel dimensions.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.segmentation_cutout" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.segmentation_cutout">segmentation_cutout</h2>
<p><code>imagery.ImageryClient.segmentation_cutout(bounds, root_ids='all', bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None, convert_to_int64=True)</code></p>
<p>Get a cutout of the segmentation imagery for some or all root ids between set bounds. Note that if all root ids are requested in a large region, it could take a long time to query all supervoxels.</p>
<section id="parameters-8" class="level3">
<h3 class="anchored" data-anchor-id="parameters-8">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 80%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bounds</code></td>
<td>2x3 list of ints</td>
<td>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>root_ids</code></td>
<td>list, None, or ‘all’</td>
<td>If a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default ‘all’</td>
<td><code>'all'</code></td>
</tr>
<tr class="odd">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>image_size</code></td>
<td>array or None</td>
<td>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>mip</code></td>
<td>int</td>
<td>Mip level of the segmentation if something other than the defualt is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>timestamp</code></td>
<td>datetime or None</td>
<td>Timestamp to use for dynamic segmentation data</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>scale_to_bounds</code></td>
<td>bool or None</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>convert_to_int64</code></td>
<td>bool</td>
<td>If True, converts segmentation data to int64 from uint64 if it is safe to do so. Default is True. If not safe, raises a warning and does not convert from uint64.</td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-4" class="level3">
<h3 class="anchored" data-anchor-id="returns-4">Returns</h3>
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>numpy.numpy.ndarray</td>
<td>Array whose elements correspond to the root id (or, if root_ids=None, the supervoxel id) at each voxel.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="imageryclient.imagery.ImageryClient.split_segmentation_cutout" class="level2">
<h2 class="anchored" data-anchor-id="imageryclient.imagery.ImageryClient.split_segmentation_cutout">split_segmentation_cutout</h2>
<p><code>imagery.ImageryClient.split_segmentation_cutout(bounds, root_ids='all', include_null_root=False, bbox_size=None, image_size=None, mip=None, resolution=None, timestamp=None, scale_to_bounds=None)</code></p>
<p>Generate segmentation cutouts with a single binary mask for each root id, organized as a dict with keys as root ids and masks as values.</p>
<section id="parameters-9" class="level3">
<h3 class="anchored" data-anchor-id="parameters-9">Parameters</h3>
<table class="table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 80%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bounds</code></td>
<td>2x3 list of ints</td>
<td>A list of the lower and upper bound point for the cutout. The units are voxels in the resolution set by the base_resolution parameter.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>root_ids</code></td>
<td>list, None, or ‘all’</td>
<td>If a list, only compute the voxels for a specified set of root ids. If None, default to the supervoxel ids. If ‘all’, find all root ids corresponding to the supervoxels in the cutout and get all of them. None, by default ‘all’</td>
<td><code>'all'</code></td>
</tr>
<tr class="odd">
<td><code>include_null_root</code></td>
<td>bool</td>
<td>If True, includes root id of 0, which is usually reserved for a null segmentation value. Default is False.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>bbox_size</code></td>
<td>array or None</td>
<td>If not None, bbox_size is a 3 element array of ints giving the dimensions. In this case, bounds is treated as the center.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>image_size</code></td>
<td>array or None</td>
<td>If not None, indicates the size of the image desired in pixels. Cannot be set with bbox_size, since it has potentially conficting information.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>mip</code></td>
<td>int</td>
<td>Mip level of the segmentation if something other than the default is wanted, by default None</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>resolution</code></td>
<td>list - like</td>
<td>Voxel resolution used when specifying bounds bounds and bbox_size (but not image_size). If none, defaults to client default.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>timestamp</code></td>
<td>datetime or None</td>
<td>Timestamp to use for dynamic segmentation data</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>scale_to_bounds</code></td>
<td>bool or None</td>
<td>If True, rescales image to the same size as the bounds. Default is None, which rescales if mip is not set but otherwise does not.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-5" class="level3">
<h3 class="anchored" data-anchor-id="returns-5">Returns</h3>
<table class="table">
<colgroup>
<col style="width: 5%">
<col style="width: 94%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dict</td>
<td>Dict whose keys are root ids and whose values are the binary mask for that root id, with a 1 where the object contains the voxel.</td>
</tr>
</tbody>
</table>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../reference/imagery.bounds_from_center.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">imagery.bounds_from_center</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../reference/composite.stack_images.html" class="pagination-link">
        <span class="nav-page-text">composite.stack_images</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>